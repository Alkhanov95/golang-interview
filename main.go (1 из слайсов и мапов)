---------------------------------------------------------------------------------------------------------------------------
//zadacha 1
//что выведет код
/*
package main

import (
	"fmt"
	"sort"
)

func main() {

	v := []int{3, 4, 1, 2, 5}
	//создается слай v = [3, 4, 1, 2, 5]
	ap(v)
	sr(v)
	fmt.Println(v)
}

func ap(arr []int) {
	arr = append(arr, 10)
	// сюда передается копия ссылки на слайс v
	// функция делает append(arr, 10) - создается новый слайс в котором уже есть 10
	// НО ЭТОТ СЛАЙС НЕ СОХРАНЯЕТСЯ ОБРАТНО В V
	//пример из жизни - представь ты дал другу копию ключей от своей квартиры. Он пошел
	//построил новую комнату но ключи оставил себе. Нам про новую комнату ничего неизвестно
	//вот так мы и создали новый слайс и не передали его
}

// а как работает append ?
//1 проверяет есть ли свободное место в слайсе
//2 если места нет - создает новый массив копирует старые элементы и добавляет новые
//3 возвращает новый слайс который указывает на новый массив
//НО! Если ты не сохраняешь результат append, то этот новый слайс теряется.

func sr(arr []int) {
	sort.Ints(arr)
	//Тут sort.Ints сортирует слайс на месте — ничего не создаёт заново.
	//Из-за этого изменения отражаются и в v.
}
// вывод [1 2 3 4 5]
/*

---------------------------------------------------------------------------------------------------------------------------
//zadacha 1.2
//сделать append рабочим

package main 

import(
	"fmt"
 	"sort"
)

func main() {
 a := []int{0, 4, 5, 2}
 ap(&a)
 sr(a)
 fmt.Println(a)
}

func ap(a *[]int) {
	*a = append(*a, 1, 6, 3)
}

func sr(arr []int){
	sort.Ints(arr)
}
// вывод [0 1 2 3 4 5 6]
---------------------------------------------------------------------------------------------------------------------------
//zadacha 1.3
// Понимание поведения append

package main 

import(
	"fmt"
)

func main() {
    s := []int{1, 2}
    s = append(s, 3)
    fmt.Println(len(s), cap(s)) // Что выведет? = // (len = 3) (cap = 4)

    s = append(s, 4)
    fmt.Println(len(s), cap(s)) // А теперь? = //(len = 4) (cap = 4)

    s = append(s, 5, 6, 7)
    fmt.Println(len(s), cap(s)) // И здесь? = // (len = 7) (cap = 8)
}
---------------------------------------------------------------------------------------------------------------------------
//zadacha 1.4
// Передача слайса в функцию

package main 

import(
	"fmt"
)

func main() {
    a := []int{1, 2, 3}
    modifySlice(a)
    fmt.Println(a) // Что будет выведено?
}

func modifySlice(s []int) {
    s = append(s, 10)
    s[0] = 99
}

// вывод [1 2 3]
---------------------------------------------------------------------------------------------------------------------------
//zadacha 1.5
// Измени предыдущую функцию так, чтобы изменения применялись к исходному слайсу:
package main 

import(
	"fmt"
)

func modifySlice(s *[]int) {
 	*s = append(*s, 10)
}

func main() {
    a := []int{1, 2, 3}
    modifySlice(&a)
    fmt.Println(a) // Должно быть [1, 2, 3, 10]
}
//вывод [1, 2, 3, 10]
---------------------------------------------------------------------------------------------------------------------------



