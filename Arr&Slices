Массивы это коллекция элементов одного типа. Длина массива не может 
изменяться. Вот как мы создаем массив в Go :

arr := [4] int {3,2,5,4}
arr := [5] int {1,2,3,4,5}
arr := [2] int {1,2}
arr := [8] int {1,2,2,2,2,2,2,2}
arr := [3] int {1,2,3}

Если мы создадим два массива в Go с разными длинами, то два массива будут
иметь разные типы, так как длина массива в Go, входит в его тип:

a := [3] int{}
a := [2] int{}
// (a) [2] int и (b) [3] int - разные типы


Более того, если нам лень писать длину массива, то мы можем сказать 
компилятору, чтобы он сам подсчитал длину:

a := [...] int {1,2,3} // [3] int


Передача по значению 
Переменная, которую мы инициализировали со значением массива, содержит именно 
значения массива, а не ссылку на первый элемент массива (как в C)

Именно поэтому массив в Go является примитивным типом данных, он может копироваться
при передаче в другую переменную. По умолчанию в Go все значения копируются, а не
передаются с помощью ссылки. Это значит, что если мы передадим наш масив в функцию
то Go скопирует данный массив в функцию будет находиться уже совершенно другой массив
(вернее точная копия исходного массива)

внизу мы рассмотрим пример где мы скопируем массив а затем посмотрим на адрес
по которому хранится значение 

package main 

import "fmt"

func main() {
var initArray = [...] int {1,2,3}
var copyArray = initArray

fmt.Printf("Address of initArray : %p\n", &initArray)
fmt.Printf("Address of copyArray: %p\n", &copyArray)
}


/*
Output:
  Address of initArray: 0xc00001a018
  Address of copyArray: 0xc00001a030
*/



Слайсы 
Слайсы в Go более гибкие, они позволяют изменять свою длину. 
По сути слайсы являются надмножеством массивов. Слайсы создают нам массив, 
которым мы можем пользоваться как обычным массивом и при надобности 
расширять его

слайсы можно создать двумя способами:

1) с помощью make :
var foo [] byte
s = make([]byte, 5, 5)

2) с помощью shorthand syntax :
a := []byte{}

Способ с make 
Способ с make является более интересным, так как дает нам возможность 
задать тип, длину и вместимость

С типом по сути никаких проблем быть не должно. Тип слайса формируется в виде
[]тип.

С длиной тоже ничего интересного. В зависимости от введеного кол-ва - массив
заполнится нулевыми значениями, например :

package main 

import "fmt"

func main() {
var foo = make ([]byte, 5)
var bar = make ([]int, 10)
var fee = make ([]string, 2)

fmt.Println(foo, bar, fee)
}


/*
Output:
  [0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [ ]
*/


Последний параметр - вместимость играет важную роль в производительности 
программы, а также является интересным. По сути он говорит о том сколько 
памяти нужно выделить заранее под наш массив, чтобы при расширении нам не 
пришлось искать новый участок памяти.

Например, если мы создадим массив с вместимостью в 10 элементов, наполним его
5 элементами, а потом добавим один - адрес массива не изменится
