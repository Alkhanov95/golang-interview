Массивы это коллекция элементов одного типа. Длина массива не может 
изменяться. Вот как мы создаем массив в Go :

arr := [4] int {3,2,5,4}
arr := [5] int {1,2,3,4,5}
arr := [2] int {1,2}
arr := [8] int {1,2,2,2,2,2,2,2}
arr := [3] int {1,2,3}

Если мы создадим два массива в Go с разными длинами, то два массива будут
иметь разные типы, так как длина массива в Go, входит в его тип:

a := [3] int{}
a := [2] int{}
// (a) [2] int и (b) [3] int - разные типы


Более того, если нам лень писать длину массива, то мы можем сказать 
компилятору, чтобы он сам подсчитал длину:

a := [...] int {1,2,3} // [3] int


Передача по значению 
Переменная, которую мы инициализировали со значением массива, содержит именно 
значения массива, а не ссылку на первый элемент массива (как в C)

Именно поэтому массив в Go является примитивным типом данных, он может копироваться
при передаче в другую переменную. По умолчанию в Go все значения копируются, а не
передаются с помощью ссылки. Это значит, что если мы передадим наш масив в функцию
то Go скопирует данный массив в функцию будет находиться уже совершенно другой массив
(вернее точная копия исходного массива)

внизу мы рассмотрим пример где мы скопируем массив а затем посмотрим на адрес
по которому хранится значение 

package main 

import "fmt"

func main() {
var initArray = [...] int {1,2,3}
var copyArray = initArray

fmt.Printf("Address of initArray : %p\n", &initArray)
fmt.Printf("Address of copyArray: %p\n", &copyArray)
}


/*
Output:
  Address of initArray: 0xc00001a018
  Address of copyArray: 0xc00001a030
*/


