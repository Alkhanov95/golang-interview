---------------------------------------------------------------------------------------------------------------------------
//zadacha 1
//что выведет код
/*
package main

import (
	"fmt"
	"sort"
)

func main() {

	v := []int{3, 4, 1, 2, 5}
	//создается слай v = [3, 4, 1, 2, 5]
	ap(v)
	sr(v)
	fmt.Println(v)
}

func ap(arr []int) {
	arr = append(arr, 10)
	// сюда передается копия ссылки на слайс v
	// функция делает append(arr, 10) - создается новый слайс в котором уже есть 10
	// НО ЭТОТ СЛАЙС НЕ СОХРАНЯЕТСЯ ОБРАТНО В V
	//пример из жизни - представь ты дал другу копию ключей от своей квартиры. Он пошел
	//построил новую комнату но ключи оставил себе. Нам про новую комнату ничего неизвестно
	//вот так мы и создали новый слайс и не передали его
}

// а как работает append ?
//1 проверяет есть ли свободное место в слайсе
//2 если места нет - создает новый массив копирует старые элементы и добавляет новые
//3 возвращает новый слайс который указывает на новый массив
//НО! Если ты не сохраняешь результат append, то этот новый слайс теряется.

func sr(arr []int) {
	sort.Ints(arr)
	//Тут sort.Ints сортирует слайс на месте — ничего не создаёт заново.
	//Из-за этого изменения отражаются и в v.
}
// вывод [1 2 3 4 5]
/*

---------------------------------------------------------------------------------------------------------------------------
//zadacha 1.2
//сделать append рабочим

package main 

import(
	"fmt"
 	"sort"
)

func main() {
 a := []int{0, 4, 5, 2}
 ap(&a)
 sr(a)
 fmt.Println(a)
}

func ap(a *[]int) {
	*a = append(*a, 1, 6, 3)
}

func sr(arr []int){
	sort.Ints(arr)
}
// вывод [0 1 2 3 4 5 6]
---------------------------------------------------------------------------------------------------------------------------
//zadacha 1.2
//сделать append рабочим

